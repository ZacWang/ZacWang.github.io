---
title: 终于消灭了一个BUG
date: 2016-03-21 21:52:31
categories: openMP
tags:
---

耗费了两三天的时间的一个bug。


<!--more-->

**问题描述：**
一个任务分配的module配合openmp，实现并行化。任务按照树状划分，但是根节点的数据会有错误。发现是由于任务分配的逻辑有问题，造成了子节点与父节点有可能处于同时计算中的状态。


任务分配的module是一两周之前就已经写好测试过的，如下：

**结构：**
task(n)为所有可能的任务
task_flag(n)为task对应的一个flag数组，标定task的状态
pool(n)为任务池

task中的任务在子节点都是完成的状态时被push到pool中。


问题就出在了判定是否将父节点push到pool中的逻辑上。

**错误的逻辑：**
task_flag有三个值:1,0,-1，分别表示当前任务未做，已做，不存在
而当一个任务被push到pool中后，对应的task_flag就被标记为0了。
在判断是否push父节点的时候，就会出现如下情况：两个子节点都被push到了pool中，因而两个子节点的flag都为0，即对应任务已做；当其中一个完成时，父节点即被push到pool中，而此时并不满足所有子节点都已经完成的条件。

**修改后的逻辑：**
task_flag有四个值:1,0,-1,-9，分别表示当前任务未做，待做，已做，不存在
当一个任务被push到pool中后，对应的task_flag就被标记为0；当任务完成后，再标记为-1。
在对父节点进行判断时，只要看看子节点是不是都是-1即可。


**反思一下：**
问题出在了对自己的盲目自信上。其实上述逻辑漏洞在当时写这个module的时候就考虑过，还自以为做足了测试，没想到还是漏掉了。测试的时候没有暴露出来是因为没有上数据，只是让分配任务这部分空转，才得出了看似合理的结果。
出了bug之后查了好多地方，最后才找到这里的问题。去查了openmp的atomic、critical等语句的用法，加上去也没啥用…折腾了两三天终于搞定了。所以说做模块测试的时候，还是要上数据跑一跑才能更有说服力。